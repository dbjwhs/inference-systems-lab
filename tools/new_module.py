#!/usr/bin/env python3
# MIT License
# Copyright (c) 2025 dbjwhs
"""
new_module.py - Scaffold new components with tests for the Inference Systems Lab

This script creates a new module with standard directory structure:
- src/ (source files)
- tests/ (test files)  
- examples/ (example/demo files)
- benchmarks/ (performance benchmarks)
- docs/ (documentation)
- CMakeLists.txt (build configuration)
- README.md (module documentation)

Usage:
    python tools/new_module.py <module_name> [--type <type>] [--author <author>]
    
Examples:
    python tools/new_module.py neural_symbolic
    python tools/new_module.py probabilistic --type library --author "Jane Doe"
"""

import argparse
import os
import sys
from pathlib import Path
from datetime import datetime
from typing import Dict, List


class ModuleScaffolder:
    """Scaffolds new modules with standard directory structure and templates."""
    
    def __init__(self, project_root: Path):
        self.project_root = project_root
        self.current_year = datetime.now().year
        
    def create_module(self, module_name: str, module_type: str = "library", 
                     author: str = "dbjwhs", description: str = "") -> bool:
        """Create a new module with standard structure."""
        
        # Validate module name
        if not self._is_valid_module_name(module_name):
            print(f"Error: Invalid module name '{module_name}'. Use lowercase letters, numbers, and underscores only.")
            return False
            
        module_path = self.project_root / module_name
        
        # Check if module already exists
        if module_path.exists():
            print(f"Error: Module '{module_name}' already exists at {module_path}")
            return False
            
        try:
            # Create directory structure
            self._create_directories(module_path)
            
            # Generate files from templates
            self._create_cmake_file(module_path, module_name, module_type)
            self._create_readme_file(module_path, module_name, description, author)
            self._create_source_files(module_path, module_name)
            self._create_test_files(module_path, module_name)
            self._create_example_files(module_path, module_name)
            self._create_benchmark_files(module_path, module_name)
            self._create_docs_files(module_path, module_name)
            
            print(f"✅ Successfully created module '{module_name}' at {module_path}")
            print(f"📁 Structure:")
            self._print_directory_tree(module_path)
            
            print(f"\n🔧 Next steps:")
            print(f"1. Add module to root CMakeLists.txt: add_subdirectory({module_name})")
            print(f"2. Implement functionality in {module_name}/src/")
            print(f"3. Add tests in {module_name}/tests/")
            print(f"4. Run: cmake --build build && ctest --test-dir build")
            
            return True
            
        except Exception as e:
            print(f"Error creating module: {e}")
            # Clean up partial creation
            if module_path.exists():
                import shutil
                shutil.rmtree(module_path)
            return False
    
    def _is_valid_module_name(self, name: str) -> bool:
        """Check if module name follows naming conventions."""
        return (len(name) > 0 and 
                name.replace('_', '').replace('-', '').isalnum() and 
                name[0].islower())
    
    def _create_directories(self, module_path: Path) -> None:
        """Create standard directory structure."""
        directories = [
            "src",
            "tests", 
            "examples",
            "benchmarks",
            "docs"
        ]
        
        for directory in directories:
            (module_path / directory).mkdir(parents=True, exist_ok=True)
    
    def _create_cmake_file(self, module_path: Path, module_name: str, module_type: str) -> None:
        """Generate CMakeLists.txt for the module."""
        cmake_content = f"""# {module_name.title()} module
# Generated by tools/new_module.py on {datetime.now().strftime('%Y-%m-%d')}

# Create {module_name} library
add_library({module_name} STATIC
    src/placeholder.cpp
)

target_include_directories({module_name} PUBLIC
    $<BUILD_INTERFACE:${{CMAKE_CURRENT_SOURCE_DIR}}/src>
    $<INSTALL_INTERFACE:include>
)

target_link_libraries({module_name}
    common
    Threads::Threads
)

# {module_name.title()} tests
add_executable({module_name}_tests
    tests/placeholder.cpp
)

target_link_libraries({module_name}_tests
    {module_name}
    ${{GTEST_MAIN_TARGET}}
)

add_test(NAME {module_name.title()}Tests COMMAND {module_name}_tests)

# {module_name.title()} benchmarks
if(TARGET benchmark::benchmark)
    add_executable({module_name}_benchmarks
        benchmarks/placeholder.cpp
    )

    target_link_libraries({module_name}_benchmarks
        {module_name}
        benchmark::benchmark_main
    )
    
    add_custom_target({module_name}_bench DEPENDS {module_name}_benchmarks)
endif()

# {module_name.title()} examples
add_executable({module_name}_demo
    examples/demo.cpp
)

target_link_libraries({module_name}_demo
    {module_name}
)
"""
        
        (module_path / "CMakeLists.txt").write_text(cmake_content)
    
    def _create_readme_file(self, module_path: Path, module_name: str, 
                           description: str, author: str) -> None:
        """Generate README.md for the module."""
        if not description:
            description = f"Implementation of {module_name.replace('_', ' ')} functionality"
            
        readme_content = f"""# {module_name.title()} Module

{description}

## Overview

This module provides {module_name.replace('_', ' ')} functionality for the Inference Systems Lab.

## Structure

- `src/` - Core implementation
- `tests/` - Unit tests
- `examples/` - Usage examples and demos
- `benchmarks/` - Performance benchmarks
- `docs/` - Technical documentation

## Building

```bash
# From project root
cmake --build build --target {module_name}
```

## Testing

```bash
# Run module tests
ctest --test-dir build -R {module_name.title()}Tests

# Run with verbose output
ctest --test-dir build -R {module_name.title()}Tests --verbose
```

## Examples

```bash
# Run demo
./build/{module_name}/{module_name}_demo
```

## Benchmarks

```bash
# Run performance benchmarks
./build/{module_name}/{module_name}_benchmarks
```

## API Documentation

See `docs/` directory for detailed API documentation.

## Contributing

Follow the patterns established in docs/DEVELOPMENT.md and docs/CONTRIBUTING.md.

---
Generated by tools/new_module.py on {datetime.now().strftime('%Y-%m-%d')}
Author: {author}
"""
        
        (module_path / "README.md").write_text(readme_content)
    
    def _create_source_files(self, module_path: Path, module_name: str) -> None:
        """Generate placeholder source files."""
        
        # Main header file
        header_content = f"""#pragma once

#include <memory>
#include <string>
#include <vector>

namespace inference_lab::{module_name} {{

/**
 * @brief Core class for {module_name.replace('_', ' ')} functionality
 */
class {self._to_pascal_case(module_name)} {{
public:
    {self._to_pascal_case(module_name)}();
    ~{self._to_pascal_case(module_name)}() = default;
    
    // Non-copyable, movable
    {self._to_pascal_case(module_name)}(const {self._to_pascal_case(module_name)}&) = delete;
    {self._to_pascal_case(module_name)}& operator=(const {self._to_pascal_case(module_name)}&) = delete;
    {self._to_pascal_case(module_name)}({self._to_pascal_case(module_name)}&&) = default;
    {self._to_pascal_case(module_name)}& operator=({self._to_pascal_case(module_name)}&&) = default;
    
    /**
     * @brief Initialize the {module_name.replace('_', ' ')} system
     * @return true if initialization successful
     */
    bool initialize();
    
    /**
     * @brief Process input data
     * @param input Input data to process
     * @return Processing result
     */
    std::string process(const std::string& input);
    
private:
    bool initialized_{{false}};
}};

}} // namespace inference_lab::{module_name}
"""
        
        (module_path / "src" / f"{module_name}.hpp").write_text(header_content)
        
        # Implementation file
        impl_content = f"""#include "{module_name}.hpp"
#include "common/src/logging.hpp"

namespace inference_lab::{module_name} {{

{self._to_pascal_case(module_name)}::{self._to_pascal_case(module_name)}() {{
    LOG_INFO("Creating {self._to_pascal_case(module_name)} instance");
}}

bool {self._to_pascal_case(module_name)}::initialize() {{
    if (initialized_) {{
        LOG_WARN("{self._to_pascal_case(module_name)} already initialized");
        return true;
    }}
    
    LOG_INFO("Initializing {self._to_pascal_case(module_name)}");
    
    // TODO: Add initialization logic
    
    initialized_ = true;
    LOG_INFO("{self._to_pascal_case(module_name)} initialized successfully");
    return true;
}}

std::string {self._to_pascal_case(module_name)}::process(const std::string& input) {{
    if (!initialized_) {{
        LOG_ERROR("Cannot process: {self._to_pascal_case(module_name)} not initialized");
        return "";
    }}
    
    LOG_DEBUG("Processing input: {{}}", input);
    
    // TODO: Add processing logic
    std::string result = "Processed: " + input;
    
    LOG_DEBUG("Processing result: {{}}", result);
    return result;
}}

}} // namespace inference_lab::{module_name}
"""
        
        (module_path / "src" / f"{module_name}.cpp").write_text(impl_content)
        
        # Placeholder file for CMake
        placeholder_content = f"""// Placeholder source file for {module_name} module
// This file ensures the library has at least one source file
// Replace with actual implementation

#include "{module_name}.hpp"

// Placeholder function to prevent empty translation unit
namespace {{
    [[maybe_unused]] void placeholder_{module_name}_function() {{
        // This function serves as a placeholder and should be removed
        // once actual implementation is added
    }}
}}
"""
        
        (module_path / "src" / "placeholder.cpp").write_text(placeholder_content)
    
    def _create_test_files(self, module_path: Path, module_name: str) -> None:
        """Generate test files."""
        
        test_content = f"""#include <gtest/gtest.h>
#include "{module_name}.hpp"

namespace inference_lab::{module_name} {{
namespace test {{

class {self._to_pascal_case(module_name)}Test : public ::testing::Test {{
protected:
    void SetUp() override {{
        // Setup for each test
        {module_name}_instance_ = std::make_unique<{self._to_pascal_case(module_name)}>();
    }}
    
    void TearDown() override {{
        // Cleanup after each test
        {module_name}_instance_.reset();
    }}
    
    std::unique_ptr<{self._to_pascal_case(module_name)}> {module_name}_instance_;
}};

TEST_F({self._to_pascal_case(module_name)}Test, ConstructorWorks) {{
    EXPECT_NE({module_name}_instance_, nullptr);
}}

TEST_F({self._to_pascal_case(module_name)}Test, InitializeWorks) {{
    EXPECT_TRUE({module_name}_instance_->initialize());
}}

TEST_F({self._to_pascal_case(module_name)}Test, ProcessAfterInitialize) {{
    EXPECT_TRUE({module_name}_instance_->initialize());
    
    std::string input = "test_input";
    std::string result = {module_name}_instance_->process(input);
    
    EXPECT_FALSE(result.empty());
    EXPECT_NE(result.find("test_input"), std::string::npos);
}}

TEST_F({self._to_pascal_case(module_name)}Test, ProcessWithoutInitialize) {{
    std::string input = "test_input";
    std::string result = {module_name}_instance_->process(input);
    
    EXPECT_TRUE(result.empty());
}}

}} // namespace test
}} // namespace inference_lab::{module_name}
"""
        
        (module_path / "tests" / f"test_{module_name}.cpp").write_text(test_content)
        
        # Placeholder test file for CMake
        placeholder_test = f"""#include <gtest/gtest.h>

// Placeholder test for {module_name} module
// Replace with actual tests

TEST(Placeholder{self._to_pascal_case(module_name)}Test, PlaceholderTest) {{
    // This is a placeholder test to ensure the test executable builds
    // Replace with actual tests for {module_name}
    EXPECT_TRUE(true);
}}
"""
        
        (module_path / "tests" / "placeholder.cpp").write_text(placeholder_test)
    
    def _create_example_files(self, module_path: Path, module_name: str) -> None:
        """Generate example files."""
        
        demo_content = f"""#include <iostream>
#include "{module_name}.hpp"
#include "common/src/logging.hpp"

int main() {{
    std::cout << "=== {self._to_pascal_case(module_name)} Demo ===" << std::endl;
    
    try {{
        // Initialize logging
        inference_lab::logging::set_log_level(inference_lab::logging::LogLevel::INFO);
        
        // Create and initialize {module_name} instance
        inference_lab::{module_name}::{self._to_pascal_case(module_name)} processor;
        
        if (!processor.initialize()) {{
            std::cerr << "Failed to initialize {module_name} processor" << std::endl;
            return 1;
        }}
        
        // Demonstrate functionality
        std::vector<std::string> test_inputs = {{
            "Hello, World!",
            "Test input 1",
            "Test input 2",
            "Complex data structure"
        }};
        
        for (const auto& input : test_inputs) {{
            std::cout << "Input: " << input << std::endl;
            std::string result = processor.process(input);
            std::cout << "Output: " << result << std::endl;
            std::cout << "---" << std::endl;
        }}
        
        std::cout << "Demo completed successfully!" << std::endl;
        return 0;
        
    }} catch (const std::exception& e) {{
        std::cerr << "Exception: " << e.what() << std::endl;
        return 1;
    }}
}}
"""
        
        (module_path / "examples" / "demo.cpp").write_text(demo_content)
        
        # Placeholder example for CMake
        placeholder_example = f"""#include <iostream>

// Placeholder example for {module_name} module
// Replace with actual usage examples

int main() {{
    std::cout << "Placeholder example for {module_name} module" << std::endl;
    std::cout << "Replace this with actual usage examples" << std::endl;
    return 0;
}}
"""
        
        (module_path / "examples" / "placeholder.cpp").write_text(placeholder_example)
    
    def _create_benchmark_files(self, module_path: Path, module_name: str) -> None:
        """Generate benchmark files."""
        
        benchmark_content = f"""#include <benchmark/benchmark.h>
#include "{module_name}.hpp"

namespace inference_lab::{module_name} {{
namespace benchmark {{

class {self._to_pascal_case(module_name)}Fixture : public ::benchmark::Fixture {{
public:
    void SetUp(const ::benchmark::State& state) override {{
        processor_ = std::make_unique<{self._to_pascal_case(module_name)}>();
        processor_->initialize();
    }}
    
    void TearDown(const ::benchmark::State& state) override {{
        processor_.reset();
    }}
    
protected:
    std::unique_ptr<{self._to_pascal_case(module_name)}> processor_;
}};

BENCHMARK_F({self._to_pascal_case(module_name)}Fixture, ProcessSmallInput)(::benchmark::State& state) {{
    std::string input = "small test input";
    
    for (auto _ : state) {{
        std::string result = processor_->process(input);
        ::benchmark::DoNotOptimize(result);
    }}
    
    state.SetItemsProcessed(state.iterations());
}}

BENCHMARK_F({self._to_pascal_case(module_name)}Fixture, ProcessLargeInput)(::benchmark::State& state) {{
    std::string input(1000, 'x'); // 1KB of data
    
    for (auto _ : state) {{
        std::string result = processor_->process(input);
        ::benchmark::DoNotOptimize(result);
    }}
    
    state.SetBytesProcessed(state.iterations() * input.size());
}}

BENCHMARK_F({self._to_pascal_case(module_name)}Fixture, InitializationCost)(::benchmark::State& state) {{
    for (auto _ : state) {{
        auto processor = std::make_unique<{self._to_pascal_case(module_name)}>();
        ::benchmark::DoNotOptimize(processor);
        bool success = processor->initialize();
        ::benchmark::DoNotOptimize(success);
    }}
}}

}} // namespace benchmark
}} // namespace inference_lab::{module_name}

BENCHMARK_MAIN();
"""
        
        (module_path / "benchmarks" / f"{module_name}_benchmarks.cpp").write_text(benchmark_content)
        
        # Placeholder benchmark for CMake
        placeholder_benchmark = f"""#include <benchmark/benchmark.h>

// Placeholder benchmark for {module_name} module
// Replace with actual performance benchmarks

static void BM_Placeholder{self._to_pascal_case(module_name)}(::benchmark::State& state) {{
    for (auto _ : state) {{
        // Placeholder benchmark
        // Replace with actual {module_name} performance tests
        ::benchmark::DoNotOptimize(42);
    }}
}}
BENCHMARK(BM_Placeholder{self._to_pascal_case(module_name)});

BENCHMARK_MAIN();
"""
        
        (module_path / "benchmarks" / "placeholder.cpp").write_text(placeholder_benchmark)
    
    def _create_docs_files(self, module_path: Path, module_name: str) -> None:
        """Generate documentation files."""
        
        architecture_doc = f"""# {module_name.title()} Architecture

## Overview

This document describes the architecture and design decisions for the {module_name} module.

## Design Goals

- **Performance**: Optimized for high-throughput processing
- **Modularity**: Clean separation of concerns
- **Testability**: Comprehensive unit and integration tests
- **Maintainability**: Clear code structure and documentation

## Key Components

### {self._to_pascal_case(module_name)} Class

The main class providing {module_name.replace('_', ' ')} functionality.

#### Responsibilities
- Initialize the processing system
- Process input data according to {module_name} algorithms
- Manage internal state and resources

#### Dependencies
- Common logging infrastructure
- Standard C++17 library components

## Usage Patterns

### Basic Usage
```cpp
#include "{module_name}.hpp"

auto processor = std::make_unique<inference_lab::{module_name}::{self._to_pascal_case(module_name)}>();
processor->initialize();
std::string result = processor->process("input data");
```

### Error Handling
The module follows RAII principles and uses the Result<T, E> pattern for error handling where appropriate.

## Performance Considerations

- Initialization cost: One-time setup overhead
- Processing latency: Per-operation processing time
- Memory usage: Runtime memory consumption patterns

See benchmarks in `benchmarks/` for detailed performance characteristics.

## Testing Strategy

- Unit tests: Individual component testing
- Integration tests: End-to-end functionality testing
- Performance tests: Benchmark-driven performance validation

## Future Enhancements

- [ ] Add asynchronous processing support
- [ ] Implement batch processing optimizations
- [ ] Add configuration management
- [ ] Extend error reporting capabilities

---
Last updated: {datetime.now().strftime('%Y-%m-%d')}
"""
        
        (module_path / "docs" / "ARCHITECTURE.md").write_text(architecture_doc)
    
    def _to_pascal_case(self, snake_case: str) -> str:
        """Convert snake_case to PascalCase."""
        return ''.join(word.capitalize() for word in snake_case.split('_'))
    
    def _print_directory_tree(self, module_path: Path, prefix: str = "") -> None:
        """Print directory tree structure."""
        items = sorted(module_path.iterdir())
        for i, item in enumerate(items):
            is_last = i == len(items) - 1
            current_prefix = "└── " if is_last else "├── "
            print(f"{prefix}{current_prefix}{item.name}")
            
            if item.is_dir() and item.name not in ['__pycache__', '.git']:
                extension = "    " if is_last else "│   "
                self._print_directory_tree(item, prefix + extension)


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Scaffold new components with tests for the Inference Systems Lab",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s neural_symbolic
  %(prog)s probabilistic --type library --author "Jane Doe"
  %(prog)s graph_algorithms --description "Graph-based inference algorithms"
        """
    )
    
    parser.add_argument("module_name", 
                       help="Name of the module to create (use snake_case)")
    parser.add_argument("--type", 
                       choices=["library", "application"], 
                       default="library",
                       help="Type of module to create (default: library)")
    parser.add_argument("--author", 
                       default="dbjwhs",
                       help="Author name for documentation (default: dbjwhs)")
    parser.add_argument("--description",
                       default="",
                       help="Module description for README")
    
    args = parser.parse_args()
    
    # Determine project root (script is in tools/ subdirectory)
    script_path = Path(__file__).resolve()
    project_root = script_path.parent.parent
    
    if not (project_root / "CMakeLists.txt").exists():
        print(f"Error: Project root not found. Expected CMakeLists.txt at {project_root}")
        sys.exit(1)
    
    scaffolder = ModuleScaffolder(project_root)
    success = scaffolder.create_module(
        module_name=args.module_name,
        module_type=args.type,
        author=args.author,
        description=args.description
    )
    
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
